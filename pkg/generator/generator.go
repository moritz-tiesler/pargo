package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type Generator struct{}

// Generate() generates the source code, formats it with format.Source(),
// writes the formatted source code to a new file, and returns the name
// of the new file.
func (g *Generator) Generate() (string, error) {
	templData, err := g.GenerateData()
	if err != nil {
		return "", fmt.Errorf("failed to generate data: %s", err)
	}

	buf, err := templData.ToSource()
	formatted, err := formatSource(buf)
	if err != nil {
		return "", fmt.Errorf("failed to format source: %s", err)
	}

	f, err := os.OpenFile(templData.OutputFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return "", fmt.Errorf("Error opening file %s: %v", templData.OutputFile, err)
	}

	_, err = f.Write(formatted)
	if err != nil {
		return f.Name(), fmt.Errorf("Error writing file %s: %v", templData.OutputFile, err)
	}

	return f.Name(), nil
}

// ToSource() returns a bytes.Buffer containing the unformatted
// source code.
func (td *TemplateData) ToSource() (bytes.Buffer, error) {

	// TODO check len(td.StructData),
	// what to write to buf if len == 0?
	var buf bytes.Buffer
	tmpl, err := template.New("generatorTemplate").Parse(GeneratorTemplate)
	if err != nil {
		return buf, err
	}

	buf.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", td.Package))

	// Write imports
	if len(td.PackageImports) > 0 {
		buf.WriteString("import (\n")
		for imp := range td.PackageImports {
			buf.WriteString(fmt.Sprintf("%s\n", imp))
		}
		buf.WriteString(")\n")
	}

	for _, d := range td.StructData {
		err = tmpl.Execute(&buf, d)
		if err != nil {
			return buf, fmt.Errorf("Error executing template for %s: %v", d.InputTypeName, err)
		}
	}

	// Format the generated code
	return buf, nil
}

// GenerateData() parses the file currently being processed via 'go generate' and
// generates the structures that will be used to generate the new struct
// definitions.
func (g Generator) GenerateData() (*TemplateData, error) {

	var templData *TemplateData
	wd, err := os.Getwd()
	if err != nil {
		return templData, fmt.Errorf("Error getting current working directory: %v", err)
	}

	inputFilePath := filepath.Join(wd, os.Getenv("GOFILE"))
	outputPkg := os.Getenv("GOPACKAGE")

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, inputFilePath, nil, parser.ParseComments)
	if err != nil {
		return templData, fmt.Errorf("Error parsing file %s: %v", inputFilePath, err)
	}

	var allStructData []*StructData
	packageImports := make(map[string]bool)

	// Always need these for validation
	packageImports["\"fmt\""] = true

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		for _, spec := range genDecl.Specs {
			// TODO: this is very error prone. either filter imports better
			// or run goimports on generated code to delete unused imports
			if importSpec, ok := spec.(*ast.ImportSpec); ok {
				importPath := importSpec.Path.Value
				packageImports[importPath] = false
			}
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			inputTypeName := typeSpec.Name.Name
			domainTypeName := inputTypeName + "Validated" // e.g., UserInput -> ValidatedUser

			var inputFields []*InputFieldData
			var domainFields []*DomainFieldData

			for _, field := range structType.Fields.List {
				if len(field.Names) == 0 { // Embedded fields or unexported fields without name
					continue
				}
				fieldName := field.Names[0].Name
				fieldType := exprToString(field.Type, packageImports)
				validateTagValue := getTagValue(field.Tag, "validate")
				jsonTagValue := getTagValue(field.Tag, "json")

				currentInputField := &InputFieldData{
					FieldName:   fieldName,
					FieldType:   fieldType,
					ValidateTag: validateTagValue,
					JSONTag:     jsonTagValue,
				}
				inputFields = append(inputFields, currentInputField)

				// Determine domain fields based on json:"-" convention only
				if jsonTagValue == "-" {
					continue // Omit field from domain struct
				}

				var tagValue string
				if field.Tag != nil {
					tagValue = field.Tag.Value
				}

				// All other fields are copied directly with their original name and type
				domainFields = append(domainFields, &DomainFieldData{
					FieldName: fieldName,
					FieldType: fieldType,
					Tag:       tagValue,
				})
			}

			allStructData = append(allStructData, &StructData{
				InputTypeName:  inputTypeName,
				DomainTypeName: domainTypeName,
				PackageName:    node.Name.Name,
				// Imports:        packageImports,
				InputFields:  inputFields,
				DomainFields: domainFields,
			})
		}
	}

	for k, v := range packageImports {
		if !v {
			delete(packageImports, k)
		}
	}

	generatedFileName := filepath.Join(
		wd,
		strings.TrimSuffix(os.Getenv("GOFILE"), ".go")+"_gen.go",
	)

	templData = &TemplateData{
		StructData:     allStructData,
		Package:        outputPkg,
		PackageImports: packageImports,
		Cwd:            wd,
		File:           inputFilePath,
		OutputFile:     generatedFileName,
	}

	return templData, nil
}

type TemplateData struct {
	// the file that was processed by go generate
	File string
	// the default output file path
	OutputFile string
	// the struct data that was gathered from the processed file
	StructData []*StructData
	// the package name of the processed file
	// this name will be added as the package name in the output file
	Package string
	// the imports that will be added to the generated source
	PackageImports map[string]bool
	// the directory where go generate is currently executed
	Cwd string
}

// StructData holds the information needed to generate code for one Input struct.
type StructData struct {
	InputTypeName  string
	DomainTypeName string
	PackageName    string
	// Imports        map[string]struct{} // Collect unique imports needed by generated code

	InputFields  []*InputFieldData  // Fields of the Input struct
	DomainFields []*DomainFieldData // Fields for the generated Domain struct
}

// InputFieldData represents a field in the Input struct.
type InputFieldData struct {
	FieldName   string
	FieldType   string
	ValidateTag string
	JSONTag     string
}

// DomainFieldData represents a field in the generated Domain struct.
type DomainFieldData struct {
	FieldName string
	FieldType string
	Tag       string // keep all struct tags after validation
	// TODO: provide rename function that does the looping over
	// []InputfieldData and []DomainFieldData
	NewName string
}

// helper for parsing struct tag values
func getTagValue(tag *ast.BasicLit, key string) string {
	if tag == nil {
		return ""
	}
	s := strings.Trim(tag.Value, "`")
	for part := range strings.FieldsSeq(s) {
		if after, ok := strings.CutPrefix(part, key+":"); ok {
			val := after
			return strings.Trim(val, "\"")
		}
	}
	return ""
}

func exprToString(expr ast.Expr, imports map[string]bool) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		if pkgIdent, ok := t.X.(*ast.Ident); ok {
			pkgPath := pkgIdent.Name
			imports[pkgPath] = true
			fmt.Printf("found imports %s\n", pkgPath)
		}
		return exprToString(t.X, imports) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + exprToString(t.X, imports)
	case *ast.ArrayType:
		return "[]" + exprToString(t.Elt, imports)
	case *ast.MapType:
		return "map[" + exprToString(t.Key, imports) + "]" + exprToString(t.Value, imports)
	default:
		return fmt.Sprintf("interface{} /* UnsupportedType: %T */", expr)
	}
}

func formatSource(buf bytes.Buffer) ([]byte, error) {
	formattedSource, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Error formatting generated Go code: %v", err)
		return buf.Bytes(), err
	}

	return formattedSource, nil
}
